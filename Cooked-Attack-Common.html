<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Cooked.Attack.Common</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">cooked-validators-0.2.0</span><ul class="links" id="page-menu"><li><a href="src/Cooked.Attack.Common.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Cooked.Attack.Common</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">The type of attacks</a></li><li><a href="#g:2">Constructing <code>Attack</code>s that return at most one modified transaction</a></li><li><a href="#g:3">Constructing <code>Attack</code>s that return zero or more modified transactions</a></li><li><a href="#g:4">Helpers to interact with <code>MockChainSt</code></a></li><li><a href="#g:5">General helpers</a></li></ul></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">type</span> <a href="#t:Attack">Attack</a> = <a href="Cooked-MockChain-Monad-Direct.html#t:MockChainSt" title="Cooked.MockChain.Monad.Direct">MockChainSt</a> -&gt; <a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a> -&gt; [<a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a>]</li><li class="src short"><a href="#v:mkAttack">mkAttack</a> :: Is k A_Traversal =&gt; Optic' k is <a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a> a -&gt; (a -&gt; <a href="http://hackage.haskell.org/packages/archive/Cabal/latest/doc/html/Distribution-Compat-Prelude-Internal.html#t:Maybe" title="Distribution.Compat.Prelude.Internal">Maybe</a> a) -&gt; <a href="Cooked-Attack-Common.html#t:Attack" title="Cooked.Attack.Common">Attack</a></li><li class="src short"><a href="#v:mkSelectAttack">mkSelectAttack</a> :: Is k A_Traversal =&gt; Optic' k is <a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a> a -&gt; (a -&gt; <a href="http://hackage.haskell.org/packages/archive/Cabal/latest/doc/html/Distribution-Compat-Prelude-Internal.html#t:Maybe" title="Distribution.Compat.Prelude.Internal">Maybe</a> a) -&gt; (<a href="http://hackage.haskell.org/packages/archive/Cabal/latest/doc/html/Distribution-Compat-Prelude-Internal.html#t:Integer" title="Distribution.Compat.Prelude.Internal">Integer</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/Cabal/latest/doc/html/Distribution-Compat-Prelude-Internal.html#t:Bool" title="Distribution.Compat.Prelude.Internal">Bool</a>) -&gt; <a href="Cooked-Attack-Common.html#t:Attack" title="Cooked.Attack.Common">Attack</a></li><li class="src short"><a href="#v:mkSplittingAttack">mkSplittingAttack</a> :: <span class="keyword">forall</span> a b k is. Is k A_Traversal =&gt; <a href="Cooked-Attack-Common.html#t:SplitStrategy" title="Cooked.Attack.Common">SplitStrategy</a> -&gt; Optic' k is <a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a> a -&gt; (<a href="Cooked-MockChain-Monad-Direct.html#t:MockChainSt" title="Cooked.MockChain.Monad.Direct">MockChainSt</a> -&gt; a -&gt; [(a, b)]) -&gt; ([b] -&gt; <a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a> -&gt; [<a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a>]) -&gt; <a href="Cooked-Attack-Common.html#t:Attack" title="Cooked.Attack.Common">Attack</a></li><li class="src short"><a href="#v:oneChange">oneChange</a> :: [(a, [(a, b)])] -&gt; [([a], [b])]</li><li class="src short"><a href="#v:allCombinations">allCombinations</a> :: [(a, [(a, b)])] -&gt; [([a], [b])]</li><li class="src short"><span class="keyword">data</span> <a href="#t:SplitStrategy">SplitStrategy</a><ul class="subs"><li>= <a href="#v:OneChange">OneChange</a></li><li>| <a href="#v:AllCombinations">AllCombinations</a></li></ul></li><li class="src short"><a href="#v:mkAccumLAttack">mkAccumLAttack</a> :: Is k A_Traversal =&gt; Optic' k is <a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a> a -&gt; (acc -&gt; a -&gt; (a, acc)) -&gt; acc -&gt; (<a href="Cooked-MockChain-Monad-Direct.html#t:MockChainSt" title="Cooked.MockChain.Monad.Direct">MockChainSt</a> -&gt; <a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a> -&gt; acc -&gt; [<a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a>]) -&gt; <a href="Cooked-Attack-Common.html#t:Attack" title="Cooked.Attack.Common">Attack</a></li><li class="src short"><a href="#v:utxosSuchThatMcst">utxosSuchThatMcst</a> :: FromData a =&gt; <a href="Cooked-MockChain-Monad-Direct.html#t:MockChainSt" title="Cooked.MockChain.Monad.Direct">MockChainSt</a> -&gt; Address -&gt; <a href="Cooked-MockChain-UtxoPredicate.html#t:UtxoPredicate" title="Cooked.MockChain.UtxoPredicate">UtxoPredicate</a> a -&gt; [(<a href="Cooked-Tx-Constraints-Type.html#t:SpendableOut" title="Cooked.Tx.Constraints.Type">SpendableOut</a>, <a href="http://hackage.haskell.org/packages/archive/Cabal/latest/doc/html/Distribution-Compat-Prelude-Internal.html#t:Maybe" title="Distribution.Compat.Prelude.Internal">Maybe</a> a)]</li><li class="src short"><a href="#v:scriptUtxosSuchThatMcst">scriptUtxosSuchThatMcst</a> :: FromData (DatumType a) =&gt; <a href="Cooked-MockChain-Monad-Direct.html#t:MockChainSt" title="Cooked.MockChain.Monad.Direct">MockChainSt</a> -&gt; TypedValidator a -&gt; (DatumType a -&gt; Value -&gt; <a href="http://hackage.haskell.org/packages/archive/Cabal/latest/doc/html/Distribution-Compat-Prelude-Internal.html#t:Bool" title="Distribution.Compat.Prelude.Internal">Bool</a>) -&gt; [(<a href="Cooked-Tx-Constraints-Type.html#t:SpendableOut" title="Cooked.Tx.Constraints.Type">SpendableOut</a>, DatumType a)]</li><li class="src short"><a href="#v:addLabel">addLabel</a> :: <a href="Cooked-Tx-Constraints-Type.html#t:LabelConstrs" title="Cooked.Tx.Constraints.Type">LabelConstrs</a> x =&gt; x -&gt; <a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a> -&gt; <a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>The type of attacks</h1></a><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Attack" class="def">Attack</a> = <a href="Cooked-MockChain-Monad-Direct.html#t:MockChainSt" title="Cooked.MockChain.Monad.Direct">MockChainSt</a> -&gt; <a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a> -&gt; [<a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a>] <a href="src/Cooked.Attack.Common.html#Attack" class="link">Source</a> <a href="#t:Attack" class="selflink">#</a></p><div class="doc"><p>The type of attacks that operate on a single transaction. The idea is that
 in every <code><a href="Cooked-MockChain-Monad-Direct.html#t:MockChainSt" title="Cooked.MockChain.Monad.Direct">MockChainSt</a></code>ate, there are number of possible modifications to a
 transaction described by the given <code><a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a></code>. Return <code>[]</code> if the modification
 does not apply. Use these attacks with the modalities from
 <code>MonadModalMockChain</code>.</p></div></div><a href="#g:2" id="g:2"><h1>Constructing <code>Attack</code>s that return at most one modified transaction</h1></a><div class="top"><p class="src"><a id="v:mkAttack" class="def">mkAttack</a> <a href="src/Cooked.Attack.Common.html#mkAttack" class="link">Source</a> <a href="#v:mkAttack" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Is k A_Traversal</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Optic' k is <a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a> a</td><td class="doc"><p>Optic focussing potentially interesting points to modify.</p></td></tr><tr><td class="src">-&gt; (a -&gt; <a href="http://hackage.haskell.org/packages/archive/Cabal/latest/doc/html/Distribution-Compat-Prelude-Internal.html#t:Maybe" title="Distribution.Compat.Prelude.Internal">Maybe</a> a)</td><td class="doc"><p>The modification to apply; return <code>Nothing</code> if you want to leave the
 given focus as it is.</p></td></tr><tr><td class="src">-&gt; <a href="Cooked-Attack-Common.html#t:Attack" title="Cooked.Attack.Common">Attack</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The simplest way to make an attack from an optic: Try to apply a given
 function of type <code>a -&gt; Maybe a</code> to all foci of an optic, modifying all foci
 that return <code>Just</code>. This attack returns a singleton list of the modified
 <code><a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a></code> if at least one modification was successful, i.e. if at least one of
 the foci evaluates to <code>Just</code>; otherwise it returns <code>[]</code>.</p></div></div><div class="top"><p class="src"><a id="v:mkSelectAttack" class="def">mkSelectAttack</a> <a href="src/Cooked.Attack.Common.html#mkSelectAttack" class="link">Source</a> <a href="#v:mkSelectAttack" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Is k A_Traversal</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Optic' k is <a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a> a</td><td class="doc"><p>Optic focussing potentially interesting points to modify.</p></td></tr><tr><td class="src">-&gt; (a -&gt; <a href="http://hackage.haskell.org/packages/archive/Cabal/latest/doc/html/Distribution-Compat-Prelude-Internal.html#t:Maybe" title="Distribution.Compat.Prelude.Internal">Maybe</a> a)</td><td class="doc"><p>The modification to apply; return <code>Nothing</code> if you want to leave the
 given focus as it is.</p></td></tr><tr><td class="src">-&gt; (<a href="http://hackage.haskell.org/packages/archive/Cabal/latest/doc/html/Distribution-Compat-Prelude-Internal.html#t:Integer" title="Distribution.Compat.Prelude.Internal">Integer</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/Cabal/latest/doc/html/Distribution-Compat-Prelude-Internal.html#t:Bool" title="Distribution.Compat.Prelude.Internal">Bool</a>)</td><td class="doc"><p>Maybe the modification applies to (i.e. returns <code>Just</code> on) more than one
 focus. Use this function to select the foci to modify by the order in which
 they are traversed. If you set this function to <code>const True</code>, you should
 probably use <code><a href="Cooked-Attack-Common.html#v:mkAttack" title="Cooked.Attack.Common">mkAttack</a></code>, because that the semantic of that function.</p></td></tr><tr><td class="src">-&gt; <a href="Cooked-Attack-Common.html#t:Attack" title="Cooked.Attack.Common">Attack</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Traverse all foci of the given optic from the left to the right, while
 counting the foci to which the modification successfully applies, and modify
 only those modifiable foci whose index satisfies a given predicate. (This is
 useful for example if you have many identical outputs on a transaction but
 you only want to modify a few of them.) This attack returns a singleton list
 of the modified <code><a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a></code> if at least one modification was successful, i.e. if
 at least one focus was modified; otherwise it returns <code>[]</code>.</p></div></div><a href="#g:3" id="g:3"><h1>Constructing <code>Attack</code>s that return zero or more modified transactions</h1></a><div class="top"><p class="src"><a id="v:mkSplittingAttack" class="def">mkSplittingAttack</a> <a href="src/Cooked.Attack.Common.html#mkSplittingAttack" class="link">Source</a> <a href="#v:mkSplittingAttack" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> a b k is. Is k A_Traversal</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Cooked-Attack-Common.html#t:SplitStrategy" title="Cooked.Attack.Common">SplitStrategy</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; Optic' k is <a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a> a</td><td class="doc"><p>Optic focussing potentially interesting points to modify</p></td></tr><tr><td class="src">-&gt; (<a href="Cooked-MockChain-Monad-Direct.html#t:MockChainSt" title="Cooked.MockChain.Monad.Direct">MockChainSt</a> -&gt; a -&gt; [(a, b)])</td><td class="doc"><p>Function that returns possible modifications of the current focus,
 together with some piece of extra information (labels)</p></td></tr><tr><td class="src">-&gt; ([b] -&gt; <a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a> -&gt; [<a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a>])</td><td class="doc"><p>function to look at a modified <code><a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a></code> and the list of labels of all
 modifications applied to it, in order to apply optional further
 modifications. The order of labels is not specified (yet?)</p></td></tr><tr><td class="src">-&gt; <a href="Cooked-Attack-Common.html#t:Attack" title="Cooked.Attack.Common">Attack</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>This attack generates potentially very many modified TxSkels, or
 potentially very few. For each focus, a list of possible modifications, each
 with an associated label, is computed. The <code><a href="Cooked-Attack-Common.html#t:SplitStrategy" title="Cooked.Attack.Common">SplitStrategy</a></code> argument
 determines how to combine modifications and labels.</p><p>By way of example, consider</p><pre>mkSplittingAttack strategy optic f g st skel</pre><p>where <code>optic</code> has three foci <code>x,y,z</code> in <code>skel</code>. Assume that for each of these
 foci, the lists of possible modifications together with their labels are
 given by</p><pre>f st x = [(x1, 'a'), (x2, 'b')]</pre><pre>f st y = [(y1, 'c'), (y2, 'd'), (y3, 'e')]</pre><pre>f st z = []</pre><p>The strategy <code><a href="Cooked-Attack-Common.html#v:OneChange" title="Cooked.Attack.Common">OneChange</a></code> passes to <code>g</code> all possible modifications of the
 intial <code><a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a></code> obtained by applying exactly one of the modifications. In the
 example, this would mean 2 + 3 + 0 = 5 modified <code><a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a></code>s, namely the ones
 corresponding to the following lists of (un)modified foci, together with
 their (singleton) lists of labels:</p><pre>[ ([x1, y,  z], &quot;a&quot;),
  ([x2, y,  z], &quot;b&quot;),
  ([x,  y1, z], &quot;c&quot;),
  ([x,  y2, z], &quot;d&quot;),
  ([x,  y3, z], &quot;e&quot;)
]</pre><p>The strategy <code><a href="Cooked-Attack-Common.html#v:AllCombinations" title="Cooked.Attack.Common">AllCombinations</a></code> passes to <code>g</code> all modifications that change at
 least focus. In the example, there are (2+1) * (3+1) * (0+1) = 12
 combinations of applied and non-applied modifications, but one of them is the
 one that leaves everything unchanged, which leaves us with the following 11:</p><pre>[ ([x,  y1, z], &quot;c&quot;),
  ([x,  y2, z], &quot;d&quot;),
  ([x,  y3, z], &quot;e&quot;),
  ([x1, y,  z], &quot;a&quot;),
  ([x1, y1, z], &quot;ac&quot;),
  ([x1, y2, z], &quot;ad&quot;),
  ([x1, y3, z], &quot;ae&quot;),
  ([x2, y,  z], &quot;b&quot;),
  ([x2, y1, z], &quot;bc&quot;),
  ([x2, y2, z], &quot;bd&quot;),
  ([x2, y3, z], &quot;be&quot;)
]</pre></div></div><div class="top"><p class="src"><a id="v:oneChange" class="def">oneChange</a> :: [(a, [(a, b)])] -&gt; [([a], [b])] <a href="src/Cooked.Attack.Common.html#oneChange" class="link">Source</a> <a href="#v:oneChange" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:allCombinations" class="def">allCombinations</a> :: [(a, [(a, b)])] -&gt; [([a], [b])] <a href="src/Cooked.Attack.Common.html#allCombinations" class="link">Source</a> <a href="#v:allCombinations" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:SplitStrategy" class="def">SplitStrategy</a> <a href="src/Cooked.Attack.Common.html#SplitStrategy" class="link">Source</a> <a href="#t:SplitStrategy" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:OneChange" class="def">OneChange</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:AllCombinations" class="def">AllCombinations</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a id="v:mkAccumLAttack" class="def">mkAccumLAttack</a> <a href="src/Cooked.Attack.Common.html#mkAccumLAttack" class="link">Source</a> <a href="#v:mkAccumLAttack" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Is k A_Traversal</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Optic' k is <a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a> a</td><td class="doc"><p>Optic focussing potentially interesting points to modify</p></td></tr><tr><td class="src">-&gt; (acc -&gt; a -&gt; (a, acc))</td><td class="doc"><p>function that describes the modification of the accumulator and the
 current focus.</p></td></tr><tr><td class="src">-&gt; acc</td><td class="doc"><p>initial accumulator</p></td></tr><tr><td class="src">-&gt; (<a href="Cooked-MockChain-Monad-Direct.html#t:MockChainSt" title="Cooked.MockChain.Monad.Direct">MockChainSt</a> -&gt; <a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a> -&gt; acc -&gt; [<a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a>])</td><td class="doc"><p>function to decide whether the traversal modified the <code><a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a></code> in the
 desired way. This will typically look like this:
 &gt; state skel acc -&gt; if someTest state skel acc
 &gt;                    then computeFinalModifications state skel acc
 &gt;                    else []</p></td></tr><tr><td class="src">-&gt; <a href="Cooked-Attack-Common.html#t:Attack" title="Cooked.Attack.Common">Attack</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A very general attack: Traverse all foci of the optic from the left to the
 right, collecting an accumulator while also (optionally) modifying the
 <code><a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a></code>. At the end, look at the modified <code><a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a></code> and the accumulator to
 decide whether the traversal was a success, or whether we should return <code>[]</code>.</p></div></div><a href="#g:4" id="g:4"><h1>Helpers to interact with <code>MockChainSt</code></h1></a><div class="top"><p class="src"><a id="v:utxosSuchThatMcst" class="def">utxosSuchThatMcst</a> :: FromData a =&gt; <a href="Cooked-MockChain-Monad-Direct.html#t:MockChainSt" title="Cooked.MockChain.Monad.Direct">MockChainSt</a> -&gt; Address -&gt; <a href="Cooked-MockChain-UtxoPredicate.html#t:UtxoPredicate" title="Cooked.MockChain.UtxoPredicate">UtxoPredicate</a> a -&gt; [(<a href="Cooked-Tx-Constraints-Type.html#t:SpendableOut" title="Cooked.Tx.Constraints.Type">SpendableOut</a>, <a href="http://hackage.haskell.org/packages/archive/Cabal/latest/doc/html/Distribution-Compat-Prelude-Internal.html#t:Maybe" title="Distribution.Compat.Prelude.Internal">Maybe</a> a)] <a href="src/Cooked.Attack.Common.html#utxosSuchThatMcst" class="link">Source</a> <a href="#v:utxosSuchThatMcst" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Cooked-MockChain-Monad.html#v:utxosSuchThat" title="Cooked.MockChain.Monad">utxosSuchThat</a></code>, but with the <code><a href="Cooked-MockChain-Monad-Direct.html#t:MockChainSt" title="Cooked.MockChain.Monad.Direct">MockChainSt</a></code>ate as an explicit argument</p></div></div><div class="top"><p class="src"><a id="v:scriptUtxosSuchThatMcst" class="def">scriptUtxosSuchThatMcst</a> :: FromData (DatumType a) =&gt; <a href="Cooked-MockChain-Monad-Direct.html#t:MockChainSt" title="Cooked.MockChain.Monad.Direct">MockChainSt</a> -&gt; TypedValidator a -&gt; (DatumType a -&gt; Value -&gt; <a href="http://hackage.haskell.org/packages/archive/Cabal/latest/doc/html/Distribution-Compat-Prelude-Internal.html#t:Bool" title="Distribution.Compat.Prelude.Internal">Bool</a>) -&gt; [(<a href="Cooked-Tx-Constraints-Type.html#t:SpendableOut" title="Cooked.Tx.Constraints.Type">SpendableOut</a>, DatumType a)] <a href="src/Cooked.Attack.Common.html#scriptUtxosSuchThatMcst" class="link">Source</a> <a href="#v:scriptUtxosSuchThatMcst" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Cooked-MockChain-Monad.html#v:scriptUtxosSuchThat" title="Cooked.MockChain.Monad">scriptUtxosSuchThat</a></code>, but with the <code><a href="Cooked-MockChain-Monad-Direct.html#t:MockChainSt" title="Cooked.MockChain.Monad.Direct">MockChainSt</a></code>ate as an explicit
 argument</p></div></div><a href="#g:5" id="g:5"><h1>General helpers</h1></a><div class="top"><p class="src"><a id="v:addLabel" class="def">addLabel</a> :: <a href="Cooked-Tx-Constraints-Type.html#t:LabelConstrs" title="Cooked.Tx.Constraints.Type">LabelConstrs</a> x =&gt; x -&gt; <a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a> -&gt; <a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a> <a href="src/Cooked.Attack.Common.html#addLabel" class="link">Source</a> <a href="#v:addLabel" class="selflink">#</a></p><div class="doc"><p>Add a label to a <code><a href="Cooked-Tx-Constraints-Type.html#t:TxSkel" title="Cooked.Tx.Constraints.Type">TxSkel</a></code>. If there is already a pre-existing label, the
 given label will be added, forming a pair <code>(newlabel, oldlabel)</code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.0</p></div></body></html>